---
title: "@extend"
table_of_contents: true
introduction: >
  При разработке страницы часто возникают случаи, когда один класс должен иметь все стили другого класса, а также свои собственные специфические стили.
  Например, [методология БЭМ](http://getbem.com/naming/) поощряет классы-модификаторы, которые относятся к тем же элементам, что и классы блоков или элементов.
  Но это может создать загроможденный HTML, склонный к ошибкам из-за того, что забыли включить оба класса, и может внести несемантические проблемы стиля в вашу разметку.
---

<%# TODO(jina): I think these code blocks should be side-by-side %>

```html
<div class="error error--serious">
  Oh no! You've been hacked!
</div>
```

```css
.error {
  border: 1px #f00;
  background-color: #fdd;
}

.error--serious {
  border-width: 3px;
}
```

Правило Sass `@extend` решает эту проблему.
Он написан `@extend <selector>` и сообщает Sass, что один селектор должен наследовать стили другого.

<% example do %>
  .error {
    border: 1px #f00;
    background-color: #fdd;

    &--serious {
      @extend .error;
      border-width: 3px;
    }
  }
  ===
  .error
    border: 1px #f00
    background-color: #fdd

    &--serious
      @extend .error
      border-width: 3px
<% end %>

Когда один класс расширяет другой, Sass стилизует все элементы, которые соответствуют расширителю, как если бы они также соответствовали расширяемому классу.
Когда один селектор класса расширяет другой, он работает точно так же, как если бы вы добавили расширенный класс к каждому элементу в вашем HTML, который уже имел расширяющийся класс.
Вы можете просто написать `class="error--serious"`, и Sass позаботится о том, чтобы он был оформлен так, как если бы он также имел `class="error"`.

Конечно, селекторы используются не только сами по себе в правилах стиля.
Sass знает, что нужно расширять *везде*, где используется селектор.
Это гарантирует, что ваши элементы будут стилизованы точно так, как если бы они соответствовали расширенному селектору.

<% example do %>
  .error:hover {
    background-color: #fee;
  }

  .error--serious {
    @extend .error;
    border-width: 3px;
  }
  ===
  .error:hover
    background-color: #fee


  .error--serious
    @extend .error
    border-width: 3px
<% end %>

<% heads_up do %>
  Расширения разрешаются после компиляции остальной части вашей таблицы стилей.
  В частности, это происходит после разрешения [родительских селекторов][parent selectors].
  Это означает, что если вы используете `@extend .error`, это не повлияет на внутренний селектор в `.error { &__icon { ... } }`.
  Это также означает, что [родительские селекторы в SassScript][parent selectors in SassScript] не могут видеть результаты расширения.

  [parent selectors]: ../style-rules/parent-selector
  [parent selectors in SassScript]: ../style-rules/parent-selector#in-sassscript
<% end %>

## Как это работает

В отличие от [миксин][mixins], которые копируют стили в текущее правило стиля, `@extend` обновляет правила стиля, содержащие расширенный селектор, так что они также содержат расширяющий селектор.
При расширении селекторов Sass выполняет *интеллектуальную унификацию*:

[mixins]: mixin

* Он никогда не генерирует селекторы вроде `#main#footer`, которые не могут соответствовать никаким элементам.

* Это гарантирует, что сложные селекторы чередуются, так что они работают независимо от того, в каком порядке вложены элементы HTML.

* Он максимально сокращает избыточные селекторы, при этом гарантируя, что специфичность больше или равна специфичности расширителя.

* Он знает, когда один селектор совпадает со всем, что делает другой, и может комбинировать их вместе.

* Он разумно обрабатывает [комбинаторы][combinators], [универсальные селекторы][universal selectors] и [псевдоклассы, содержащие селекторы][pseudo-classes that contain selectors].

[combinators]: https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors#Combinators
[pseudo-classes that contain selectors]: https://developer.mozilla.org/en-US/docs/Web/CSS/:not
[universal selectors]: https://developer.mozilla.org/en-US/docs/Web/CSS/Universal_selectors

<% example do %>
  .content nav.sidebar {
    @extend .info;
  }

  // Это не будет расширено, потому что `p` несовместимо с `nav`.
  p.info {
    background-color: #dee9fc;
  }

  // Невозможно узнать, будет ли `<div class="guide">` внутри или снаружи
  // `<div class="content">`, поэтому Sass генерирует оба, чтобы быть в безопасности.
  .guide .info {
    border: 1px solid rgba(#000, 0.8);
    border-radius: 2px;
  }

  // Sass знает, что каждый элемент, соответствующий "main.content", также соответствует
  // ".content" и избегает создания ненужных чередующихся селекторов.
  main.content .info {
    font-size: 0.8em;
  }
  ===
  .content nav.sidebar
    @extend .info


  // Это не будет расширено, потому что `p` несовместимо с `nav`.
  p.info
    background-color: #dee9fc


  // Невозможно узнать, будет ли `<div class="guide">` внутри или снаружи
  // `<div class="content">`, поэтому Sass генерирует оба, чтобы быть в безопасности.
  .guide .info
    border: 1px solid rgba(#000, 0.8)
    border-radius: 2px


  // Sass знает, что каждый элемент, соответствующий "main.content", также соответствует
  // ".content" и избегает создания ненужных чередующихся селекторов.
  main.content .info
    font-size: 0.8em
<% end %>

<% fun_fact do %>
  Вы можете напрямую получить доступ к интеллектуальной унификации Sass, используя [функции выбора][selector functions]! [Функция `selector.unify()`][`selector.unify()` function] возвращает селектор, который соответствует пересечению двух селекторов, в то время как [функция `selector.extend()`][`selector.extend()` function] работает так же, как `@extend`, но с одним селектором.

  [selector functions]: ../modules/selector
  [`selector.unify()` function]: ../modules/selector#unify
  [`selector.extend()` function]: ../modules/selector#extend
<% end %>

<% heads_up do %>
  Поскольку `@extend` обновляет правила стиля, которые содержат расширенный селектор, их стили имеют приоритет в [каскаде][the cascade] в зависимости от того, где появляются правила стиля расширенного селектора, *а не* в зависимости от того, где появляется `@extend`.
  Это может сбивать с толку, но помните: это тот же приоритет, который имели бы эти правила, если бы вы добавили расширенный класс в свой HTML!

  [the cascade]: https://developer.mozilla.org/en-US/docs/Web/CSS/Cascade
<% end %>

## Селекторы заполнителей

Иногда вы хотите написать правило стиля, которое *только* предназначено для расширения.
В этом случае вы можете использовать [селекторы-заполнители][placeholder selectors], которые выглядят как селекторы классов, начинающиеся с `%` вместо `.`.
Любые селекторы, которые включают заполнители, не включаются в вывод CSS, но расширяют их.

[placeholder selectors]: ../style-rules/placeholder-selectors

<%= partial "code-snippets/example-placeholder" %>

### Частные заполнители

Как и [участники модуля][module members], селектор-заполнитель можно пометить как частный, начав его имя с `-` или `_`.
Селектор частного заполнителя может быть расширен только внутри таблицы стилей, которая его определяет.
Для любых других таблиц стилей это будет выглядеть так, как будто этого селектора не существует.

[module members]: use#private-members

## Область расширения

Когда одна таблица стилей расширяет селектор, это расширение будет влиять только на правила стиля, написанные в *восходящих* модулях, то есть на модули, которые загружаются этой таблицей стилей с помощью [правила `@use`][`@use` rule] или [правилоа `@forward`][`@forward` rule], модули, загруженные *этими* модулями, и так далее.
Это помогает сделать ваши правила `@extend` более предсказуемыми, гарантируя, что они влияют только на стили, о которых вы знали, когда их писали.

[`@use` rule]: use
[`@forward` rule]: forward

<% heads_up do %>
  Расширения вообще не имеют области видимости, если вы используете [правило `@import`][`@import` rule].
  Они не только повлияют на каждую импортируемую вами таблицу стилей, но и повлияют на каждую таблицу стилей, которая импортирует вашу таблицу стилей, все остальное, что эти таблицы стилей импортируют, и так далее.
  Без `@use`, расширения будут *глобальными*.

  [`@import` rule]: import
<% end %>

## Обязательные и необязательные расширения

Обычно, если `@extend` не соответствует ни одному селектору в таблице стилей, Sass выдаст ошибку.
Это помогает защитить от опечаток или переименования селектора без переименования селекторов, которые от него наследуются.
Расширения, требующие наличия расширенного селектора, являются *обязательными*.

Однако это не всегда может быть тем, что вам нужно.
Если вы хотите, чтобы `@extend` не выполнял никаких действий, если расширенный селектор не существует, просто добавьте в конец `!optional`.

## Расширения или Миксины?

Расширения и [примеси][mixins] - это способы инкапсуляции и повторного использования стилей в Sass, что, естественно, поднимает вопрос о том, когда какой из них использовать.
Миксины, очевидно, необходимы, когда вам нужно настроить стили с помощью [аргументов][arguments], но что, если они всего лишь фрагменты стилей?

[arguments]: mixin#arguments

Как показывает опыт, расширения - лучший вариант, когда вы выражаете отношения между семантическими классами (или другими семантическими селекторами). Поскольку элемент с классом `.error--serious` *является* ошибкой, для него имеет смысл расширить `.error`.
Но для несемантических коллекций стилей написание миксина может избежать каскадных головных болей и упростить настройку в дальнейшем.

<% fun_fact do %>
  Большинство веб-серверов сжимают обслуживаемый ими CSS, используя алгоритм, который очень хорошо обрабатывает повторяющиеся фрагменты идентичного текста.
  Это означает, что, хотя миксины могут создавать больше CSS, чем расширять, они, вероятно, не существенно увеличат объем, необходимый вашим пользователям для загрузки.
  Так что выбирайте ту функцию, которая больше всего подходит для вашего варианта использования, а не ту, которая генерирует меньше всего CSS!

  [gzip]: https://en.wikipedia.org/wiki/Gzip
<% end %>

## Ограничения

### Запрещенные селекторы

<% impl_status dart: true, libsass: false, ruby: false, feature: "No Compound Extensions" do %>
  LibSass и Ruby Sass в настоящее время позволяют расширять составные селекторы, такие как `.message.info`.
  Однако это поведение не соответствует определению `@extend`: вместо стилизованных элементов, которые соответствуют расширяющему селектору, как если бы он имел `class="message info"`, на который бы повлияли правила стиля, которые включали либо `.message` *или* `.info`, он стилизовал их только с помощью правил, включающих как `.message` *и* `info`.

  Для того чтобы определение `@extend` было прямым и понятным, а реализация была чистой и эффективной, такое поведение теперь устарело и будет удалено из будущих версий.

  Смотрите [страницу критических изменений][the breaking change page] для получения более подробной информации.

  [the breaking change page]: ../breaking-changes/extend-compound
<% end %>

Только *простые селекторы* - отдельные селекторы, такие как `.info` или `a` могут быть расширены.
Если бы `.message.info` мог быть расширен, определение `@extend` говорит, что элементы, соответствующие расширителю, будут иметь такой стиль, как если бы они соответствовали `.message.info`.
Это то же самое, что и сопоставление `.message` и `.info`, поэтому писать это вместо `@extend .message, .info` не принесет никакой пользы.

Точно так же, если бы `.main .info` можно было расширить, он бы делал (почти) то же самое, что и расширение `.info` самостоятельно.
Тонкие различия не стоят того, чтобы выглядеть так, будто он делает что-то существенно другое, так что это тоже недопустимо.

<% example(autogen_css: false) do %>
  .alert {
    @extend .message.info;
    //      ^^^^^^^^^^^^^
    // Error: Write @extend .message, .info instead.

    @extend .main .info;
    //      ^^^^^^^^^^^
    // Error: write @extend .info instead.
  }
  ===
  .alert
    @extend .message.info
    //      ^^^^^^^^^^^^^
    // Error: Write @extend .message, .info instead.

    @extend .main .info
    //      ^^^^^^^^^^^
    // Error: write @extend .info instead.
<% end %>

### HTML-эвристика

Когда `@extend` [чередует сложные селекторы][interleaves complex selectors], он не генерирует все возможные комбинации селекторов предков.
Многие из селекторов, которые он мог бы сгенерировать, вряд ли действительно будут соответствовать реальному HTML, и создание их всех сделало бы таблицы стилей слишком большими для очень небольшой реальной ценности.
Вместо этого он использует [эвристику][heuristic]: он предполагает, что предки каждого селектора будут самодостаточными, без чередования с предками других селекторов.

[interleaves complex selectors]: #how-it-works
[heuristic]: https://en.wikipedia.org/wiki/Heuristic

<% example do %>
  header .warning li {
    font-weight: bold;
  }

  aside .notice dd {
    // Sass не генерирует CSS для соответствия <dd> в
    //
    // <header>
    //   <aside>
    //     <div class="warning">
    //       <div class="notice">
    //         <dd>...</dd>
    //       </div>
    //     </div>
    //   </aside>
    // </header>
    //
    // потому что сопоставление всех таких элементов потребовало бы,
    // чтобы мы сгенерировали девять новых селекторов вместо двух.
    @extend li;
  }
  ===
  header .warning li
    font-weight: bold


  aside .notice dd
    // Sass не генерирует CSS для соответствия <dd> в
    //
    // <header>
    //   <aside>
    //     <div class="warning">
    //       <div class="notice">
    //         <dd>...</dd>
    //       </div>
    //     </div>
    //   </aside>
    // </header>
    //
    // потому что сопоставление всех таких элементов потребовало бы,
    // чтобы мы сгенерировали девять новых селекторов вместо двух.
    @extend li
<% end %>

### Расширить в `@media`

Хотя `@extend` разрешен в [`@media` и других at-правилах CSS][`@media` and other CSS at-rules], не разрешено расширять селекторы, которые появляются вне его at-правила.
Это связано с тем, что расширяемый селектор применяется только в пределах данного медиа-контекста, и нет способа убедиться, что ограничение сохраняется в сгенерированном селекторе без дублирования всего правила стиля.

[`@media` and other CSS at-rules]: css

<% example(autogen_css: false) do %>
  @media screen and (max-width: 600px) {
    .error--serious {
      @extend .error;
      //      ^^^^^^
      // Error: ".error" was extended in @media, but used outside it.
    }
  }

  .error {
    border: 1px #f00;
    background-color: #fdd;
  }
  ===
  @media screen and (max-width: 600px)
    .error--serious
      @extend .error
      //      ^^^^^^
      // Error: ".error" was extended in @media, but used outside it.



  .error
    border: 1px #f00
    background-color: #fdd
<% end %>
