---
title: "Мигратор"
table_of_contents: true
introduction: >
  Мигратор Sass автоматически обновляет ваши файлы Sass, чтобы помочь вам перейти на последнюю и лучшую версию языка.
  Каждая из его команд переносит отдельную функцию, чтобы вы могли максимально контролировать, что и когда обновлять.
---

## Применение

Чтобы использовать Sass migrator, сообщите ему [какую миграцию][which migration] вы хотите запустить и какие файлы Sass вы хотите перенести:

[which migration]: #migrations

```
sass-migrator <migration> <entrypoint.scss...>
```

По умолчанию мигратор изменяет только файлы, которые вы явно передаете в командной строке.
Передача [параметра `--migrate-deps`][`--migrate-deps` option] указывает мигратору также изменить все таблицы стилей, которые загружаются с использованием [правила `@use`][`@use` rule], [правила `@forward`][`@forward` rule] или [правила `@import`][`@import` rule].
А если вы хотите выполнить тестовый запуск, чтобы увидеть, какие изменения будут внесены без их фактического сохранения, вы можете передать <code>[--dry-run][] [--verbose][]</code> (или `-nv` для краткости).

[`--migrate-deps` option]: #migrate-deps
[`@use` rule]: ../at-rules/use
[`@forward` rule]: ../at-rules/forward
[`@import` rule]: ../at-rules/import
[--dry-run]: #dry-run
[--verbose]: #verbose

<%= partial 'code-snippets/example-module-migrator' %>

## Установка

Вы можете установить Sass migrator почти из тех же мест, где вы можете установить [Dart Sass](/dart-sass):

### Автономный

Вы можете установить Sass migrator в Windows, Mac или Linux, загрузив пакет для своей операционной системы [из GitHub][] и [добавив его в свой `PATH`][adding it to your `PATH`].

[from GitHub]: <%= release_url(:migrator) %>
[adding it to your `PATH`]: https://katiek2.github.io/path-doc/

### npm

Если вы используете Node.js, вы также можете установить Sass мигратор с помощью [npm][], запустив

[npm]: https://www.npmjs.com

```
npm install -g sass-migrator
```

### Chocolatey

Если вы используете [диспетчер пакетов Chocolatey][the Chocolatey package manager] для Windows, вы можете установить Sass migrator, запустив

[the Chocolatey package manager]: https://chocolatey.org

```
choco install sass-migrator
```

### Homebrew

Если вы используете [менеджер пакетов Homebrew][the Homebrew package manager] для Mac OS X, вы можете установить Dart Sass, запустив

[the Homebrew package manager]: https://brew.sh

```
brew install sass/sass/migrator
```

## Глобальные опции

Эти параметры доступны для всех мигрантов.

### `--migrate-deps`

Эта опция (сокращенно `-d`) указывает мигратору изменять не только таблицы стилей, которые явно передаются в командной строке, но также любые таблицы стилей, от которых они зависят, используя [правило `@use`][`@use` rule], [правило `@forward`][`@forward` rule] или [правило `@import`][`@import` rule].

```shellsession
$ sass-migrator module --verbose style.scss
Migrating style.scss
$ sass-migrator module --verbose --migrate-deps style.scss
Migrating style.scss
Migrating _theme.scss
Migrating _fonts.scss
Migrating _grid.scss
```

<% heads_up do %>
  [Мигратор модулей][module migrator] предполагает, что любая таблица стилей, зависящая от использования [правила `@use`][`@use` rule] или [правило `@forward`][`@forward` rule] уже была перенесена в систему модулей, поэтому он не будет пытаться перенести их, даже если передана опция `--migrate-deps`.

  [module migrator]: #module
  [`@use` rule]: ../at-rules/use
  [`@forward` rule]: ../at-rules/forward
<% end %>

### `--load-path`

Эта опция (сокращенно `-I`) сообщает мигратору [путь загрузки][load path], где он должен искать таблицы стилей.
Его можно передавать несколько раз, чтобы обеспечить несколько путей загрузки.
Более ранние пути загрузки имеют приоритет над более поздними.

Предполагается, что зависимости, загруженные из путей загрузки, являются сторонними библиотеками, поэтому мигратор не будет их переносить, даже если передан [параметр `--migrate-deps`][`--migrate-deps` option].

[load path]: ../at-rules/use#load-paths

### `--dry-run`

Этот флаг (сокращенно `-n`) говорит мигратору не сохранять никаких изменений на диск.
Вместо этого он печатает список файлов, которые он мог бы изменить.
Обычно это используется вместе с [параметром `--verbose`][`--verbose` option] для вывода содержимого изменений, которые также были бы внесены.

[`--verbose` option]: #verbose

```shellsession
$ sass-migrator module --dry-run --migrate-deps style.scss
Dry run. Logging migrated files instead of overwriting...

style.scss
_theme.scss
_fonts.scss
_grid.scss
```

#### `--no-unicode`

Этот флаг указывает программе миграции Sass только передавать на терминал символы ASCII как часть сообщений об ошибках.
По умолчанию или если передан `--unicode`, средство миграции будет выдавать для этих сообщений символы, отличные от ASCII.
Этот флаг не влияет на вывод CSS.

```shellsession
$ sass-migrator --no-unicode module style.scss
line 1, column 9 of style.scss: Error: Could not find Sass file at 'typography'.
  ,
1 | @import "typography";
  |         ^^^^^^^^^^^^
  '
Migration failed!
$ sass-migrator --unicode module style.scss
line 1, column 9 of style.scss: Error: Could not find Sass file at 'typography'.
  ╷
1 │ @import "typography";
  │         ^^^^^^^^^^^^
  ╵
Migration failed!
```

### `--verbose`

Этот флаг (сокращенно `-v`) указывает мигратору вывести дополнительную информацию на консоль.
По умолчанию он просто печатает имена файлов, которые были изменены, но в сочетании с [параметром `--dry-run`][`--dry-run` option] он также печатает новое содержимое этих файлов.

[`--dry-run` option]: #dry-run

<%# Сделайте отступ, потому что в противном случае генератор оглавления интерпретирует `===` как заголовок. %>

    $ sass-migrator module --verbose --dry-run style.scss
    Dry run. Logging migrated files instead of overwriting...
    <==> style.scss
    @use "bootstrap" with (
      $body-bg: #000,
      $body-color: #111
    );

    @include bootstrap.media-breakpoint-up(sm) {
      .navbar {
        display: block;
      }
    }
    $ sass-migrator module --verbose style.scss
    Migrating style.scss

## Миграции

### Модуль

Эта миграция преобразует таблицы стилей, которые используют старое [правило `@import`][`@import` rule] для загрузки зависимостей, так что они вместо этого используют систему модулей Sass через [правило `@use`][`@use` rule]. Он не просто наивно меняет `@import` на `@use` — он разумно обновляет таблицы стилей, чтобы они продолжали работать так же, как и раньше, в том числе::

* Добавление пространств имен для использования участников (переменных, миксинов и функций) из других модулей.

* Добавление новых правил `@use` в таблицы стилей, которые использовали элементы, без их импорта.

* Преобразование переопределенных переменных по умолчанию в [предложения `with`][`with` clauses].

  [`with` clauses]: ../at-rules/use#configuration

* Автоматическое удаление префиксов `-` и `_` из участников, которые используются из других файлов (потому что в противном случае они будут считаться [частными][private] и могут использоваться только в том модуле, который они объявлены).

  [private]: ../at-rules/use#private-members

* Преобразование [вложенного импорта][nested imports] для использования вместо него [миксины `meta.load-css()`][`meta.load-css()` mixin].

  [nested imports]: ../at-rules/import#nesting
  [`meta.load-css()` mixin]: ../modules/meta#load-css

<% heads_up do %>
  Поскольку переносчику модуля может потребоваться изменить определения участников *и* имена участников, важно либо запустить его с [параметром `--migrate-deps`][`--migrate-deps` option], либо убедиться, что вы передали ему все таблицы стилей в вашем пакете, либо заявление.

  [`--migrate-deps` option]: #migrate-deps
<% end %>

<%= partial 'code-snippets/example-module-migrator' %>

#### Загрузка зависимостей

Мигратор модуля должен иметь возможность читать все таблицы стилей, зависящие от тех, которые он мигрирует, даже если [параметр `--migrate-deps`][`--migrate-deps` option] не передан.
Если мигратору не удается найти зависимость, вы получите сообщение об ошибке.

```shellsession
$ ls .
style.scss  node_modules
$ sass-migrator module style.scss
Error: Could not find Sass file at 'dependency'.
  ,
1 | @import "dependency";
  |         ^^^^^^^^^^^^
  '
  style.scss 1:9  root stylesheet
Migration failed!
$ sass-migrator --load-path node_modules module style.scss
```

Если вы используете [путь загрузки][load path] при компиляции таблиц стилей, не забудьте передать его в программу миграции с помощью [параметра `--load-path`][`--load-path` option].

К сожалению, переносчик не поддерживает настраиваемые импортеры, но он имеет встроенную поддержку для разрешения URL-адресов, начинающихся с `~`, путем поиска в `node_modules`, аналогично [что поддерживает Webpack][what Webpack supports].

[load path]: ../at-rules/use#load-paths
[`--load-path` option]: #load-path
[what Webpack supports]: https://github.com/webpack-contrib/sass-loader#resolving-import-at-rules

#### `--remove-prefix`

Эта опция (сокращенно `-p`) принимает префикс идентификатора, который удаляется из начала всех имен переменных, миксинов и функций при их переносе.
Участники, которые не начинаются с этого префикса, останутся без изменений.

[Правило `@import`][`@import` rule] помещает все элементы верхнего уровня в одну глобальную область видимости, поэтому, когда это был стандартный способ загрузки таблиц стилей, каждый был мотивирован добавлять префиксы ко всем именам своих участников, чтобы избежать случайного переопределения некоторых других таблиц стилей.
Модульная система решает эту проблему, поэтому теперь полезно автоматически удалять старые префиксы, когда они не нужны.

```shellsession
$ cat style.scss
@import "theme";

@mixin app-inverted {
  color: $app-bg-color;
  background-color: $app-color;
}
$ sass-migrator --migrate-deps module --remove-prefix=app- style.scss
$ cat style.scss
@import "theme";

@mixin inverted {
  color: theme.$bg-color;
  background-color: theme.$color;
}
```

Когда вы передаете эту опцию, мигратор также сгенерирует [таблицу стилей только для импорта][import-only stylesheet], которая [пересылает][forwards] всех участников с добавленным префиксом обратно, чтобы сохранить обратную совместимость для пользователей, которые импортировали библиотеку.

[import-only stylesheet]: ../at-rules/import#import-only-files
[forwards]: ../at-rules/forward

Этот параметр может передаваться несколько раз или с несколькими значениями, разделенными запятыми.
Каждый префикс будет удален из всех участников, у которых он есть.
Если член соответствует нескольким префиксам, будет удален самый длинный совпадающий префикс.

#### `--forward`

Эта опция сообщает мигратору, какие элементы перенаправлять с помощью [правила `@forward`][`@forward` rule].
Он поддерживает следующие настройки:

* `none` (по умолчанию) не пересылает участников.

* `all` перенаправляет все элементы, кроме тех, которые начинались с `-` или `_` в исходной таблице стилей, поскольку это обычно использовалось для обозначения закрытого члена пакета до того, как была введена модульная система.

* `prefixed` пересылает только те элементы, которые начинаются с префикса, переданного в [параметр `--remove-prefix`][`--remove-prefix` option]. Этот параметр можно использовать только вместе с параметром `--remove-prefix`.

  [`--remove-prefix` option]: #remove-prefix

Все файлы, которые явно передаются в командной строке, будут перенаправлять элементы, которые транзитивно загружаются этими файлами с использованием правила `@import`.
Файлы, загруженные с использованием [параметра `--migrate-deps`][`--migrate-deps` option], не будут пересылать новых участников.
Этот параметр особенно полезен при миграции библиотеки Sass, поскольку он гарантирует, что пользователи этой библиотеки по-прежнему будут иметь доступ ко всем членам, которые она определяет.

```shellsession
$ cat _index.scss
@import "theme";
@import "typography";
@import "components";
$ sass-migrator --migrate-deps module --forward=all style.scss
$ cat _index.scss
@forward "theme";
@forward "typography";
@forward "components";
```

### Пространство имен

Эта миграция позволяет вам легко изменять [пространства имен][namespaces] правил `@use` в таблице стилей.
Это полезно, если пространства имен, которые модуль миграции генерирует для разрешения конфликтов, не идеальны, или если вы не хотите использовать пространство имен по умолчанию, которое Sass определяет на основе URL-адреса правила.

[namespaces]: ../at-rules/use#choosing-a-namespace

#### `--rename`

Вы можете указать мигратору, какие пространства имен вы хотите изменить, передав выражения в параметр `--rename`.

Эти выражения имеют форму от `<old-namespace> до <new-namespace>` или `url <rule-url> до <new-namespace>`.
В этих выражениях, `<old-namespace>` и `<rule-url>` являются [регулярными выражениями][regular expressions], которые совпадают со всем существующим пространством имен или URL-адресом правила `@use`, соответственно.

[regular expressions]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions

Для простых случаев использования это выглядит как `--rename 'old to new'`, которое переименовало бы правило `@use` с пространством имен `old` в `new`.

Однако вы также можете сделать это для выполнения более сложных переименований.
Например, предположим, что ранее у вас была таблица стилей, которая выглядела так:

```scss
@import "components/button/lib/mixins";
@import "components/input/lib/mixins";
@import "components/table/lib/mixins";
// ...
```

Поскольку все эти URL-адреса будут иметь пространство имен по умолчанию `mixins` при миграции на правила `@use`, модуль миграции модуля может в конечном итоге сгенерировать что-то вроде этого:

```scss
@use "components/button/lib/mixins" as button-lib-mixins;
@use "components/input/lib/mixins" as input-lib-mixins;
@use "components/table/lib/mixins" as table-lib-mixins;
// ...
```

Это допустимый код, поскольку пространства имен не конфликтуют, но они намного сложнее, чем должны быть.
Соответствующая часть URL-адреса - это имя компонента, поэтому мы можем использовать средство миграции пространства имен для извлечения этой части.

Если мы запустим средство переноса пространства имен с помощью `--rename 'url components/(\w+)/lib/mixins to \1'`, мы получим:

```scss
@use "components/button/lib/mixins" as button;
@use "components/input/lib/mixins" as input;
@use "components/table/lib/mixins" as table;
// ...
```

Сценарий переименования здесь говорит, что нужно найти все правила `@use` URL-адреса которых выглядят как `components/(\w+)/lib/mixins` (`\w+` в регулярном выражении означает соответствие любому слову из одного или нескольких символов).
`\1` в предложении вывода означает замену содержимого первого набора круглых скобок в регулярном выражении (вызываемом [группа][group]).

[group]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions/Groups_and_Ranges

Если вы хотите применить несколько переименований, вы можете передать параметр `--rename` несколько раз или разделить их точкой с запятой или разрывом строки.
Будет использовано только первое переименование, применимое к данному правилу, поэтому вы можете передать что-то вроде `--rename 'a to b; b to a'`, чтобы поменять местами пространства имён `a` и `b`.

#### `--force`

По умолчанию, если два или более правил `@use` имеют одно и то же пространство имен после миграции, мигратор завершится ошибкой и никакие изменения не будут внесены.

В этом случае вы обычно хотите изменить свой сценарий `--rename`, чтобы избежать конфликтов, но если вы предпочитаете принудительную миграцию, вы можете вместо этого передать `--force`.

С помощью `--force`, если возникают какие-либо конфликты, первое правило `@use` получит свое предпочтительное пространство имен, тогда как последующие правила `@use` с тем же предпочтительным пространством имен вместо этого будут иметь добавленный числовой суффикс.
