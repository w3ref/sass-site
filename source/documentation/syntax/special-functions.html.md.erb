---
title: Специальные функции
table_of_contents: true
introduction: >
  CSS определяет множество функций, и большинство из них прекрасно работают с обычным синтаксисом функций Sass.
  Они анализируются как вызовы функций, преобразуются в [простые функции CSS](../at-rules/function#plain-css-functions) и компилируются как есть в CSS.
  Однако есть несколько исключений, которые имеют особый синтаксис, который нельзя просто проанализировать как [выражение SassScript](structure#expressions).
  Все вызовы специальных функций возвращают [строки без кавычек](../values/strings#unquoted).
---

## `url()`

Функция [`url()`][`url()` function] обычно используется в CSS, но ее синтаксис отличается от других функций: она может принимать либо цитируемый, *либо* URL без кавычек.
Поскольку URL-адрес без кавычек не является допустимым выражением SassScript, Sass требует специальной логики для его анализа.

[`url()` function]: https://developer.mozilla.org/en-US/docs/Web/CSS/url

Если аргумент `url()` является допустимым URL без кавычек, Sass анализирует его как есть, хотя [интерполяция][interpolation] также может использоваться для вставки значений SassScript. Если это недействительный URL без кавычек - например, если он содержит [переменные][variables] или [][функции вызова] — он анализируется как обычный [простой вызов функции CSS][plain CSS function call].

[interpolation]: ../interpolation
[variables]: ../variables
[function calls]: ../at-rules/function
[plain CSS function call]: ../at-rules/function#plain-css-functions

<% example do %>
  $roboto-font-path: "../fonts/roboto";

  @font-face {
      // Это анализируется как обычный вызов функции, который принимает строку в кавычках.
      src: url("#{$roboto-font-path}/Roboto-Thin.woff2") format("woff2");

      font-family: "Roboto";
      font-weight: 100;
  }

  @font-face {
      // Это анализируется как обычный вызов функции, который принимает арифметическое выражение.
      src: url($roboto-font-path + "/Roboto-Light.woff2") format("woff2");

      font-family: "Roboto";
      font-weight: 300;
  }

  @font-face {
      // Это анализируется как интерполированная специальная функция.
      src: url(#{$roboto-font-path}/Roboto-Regular.woff2) format("woff2");

      font-family: "Roboto";
      font-weight: 400;
  }
  ===
  $roboto-font-path: "../fonts/roboto"

  @font-face
      // Это анализируется как обычный вызов функции, который принимает строку в кавычках.
      src: url("#{$roboto-font-path}/Roboto-Thin.woff2") format("woff2")

      font-family: "Roboto"
      font-weight: 100


  @font-face
      // Это анализируется как обычный вызов функции, который принимает арифметическое выражение.
      src: url($roboto-font-path + "/Roboto-Light.woff2") format("woff2")

      font-family: "Roboto"
      font-weight: 300


  @font-face
      // Это анализируется как интерполированная специальная функция.
      src: url(#{$roboto-font-path}/Roboto-Regular.woff2) format("woff2")

      font-family: "Roboto"
      font-weight: 400
<% end %>

## `calc()`, `clamp()`, `element()`, `progid:...()`, and `expression()`

<% impl_status dart: "1.31.0", libsass: false, ruby: false, feature: "clamp()" do %>
  LibSass, Ruby Sass и более старые версии Dart Sass рассматривают `clamp()` как [простую функцию CSS][plain CSS function], а не поддерживают в ней специальный синтаксис.

  [plain CSS function]: ../at-rules/function#plain-css-functions
<% end %>

Функции [`calc()`], [`clamp()`] и [`element()`] определены в спецификации CSS.
Поскольку математические выражения `calc()` конфликтуют с арифметикой Sass, а идентификаторы `element()` могут быть проанализированы как цвета, они нуждаются в специальном анализе.

[`calc()`]: https://developer.mozilla.org/en-US/docs/Web/CSS/calc
[`clamp()`]: https://developer.mozilla.org/en-US/docs/Web/CSS/clamp
[`element()`]: https://developer.mozilla.org/en-US/docs/Web/CSS/element

[`expression()`][] и функции, начинающиеся с [`progid:`][] являются устаревшими функциями Internet Explorer, которые используют нестандартный синтаксис.
Хотя последние версии браузеров больше не поддерживают их, Sass продолжает анализировать их на предмет обратной совместимости.

[`expression()`]: https://blogs.msdn.microsoft.com/ie/2008/10/16/ending-expressions/
[`progid:`]: https://blogs.msdn.microsoft.com/ie/2009/02/19/the-css-corner-using-filters-in-ie8/

Sass допускает *любой текст* в этих вызовах функций, включая вложенные круглые скобки. Ничто не интерпретируется как выражение SassScript, за исключением того, что [интерполяция][interpolation] может использоваться для вставки динамических значений.

<% example do %>
  @use "sass:math";

  .logo {
    $width: 800px;
    width: $width;
    position: absolute;
    left: calc(50% - #{math.div($width, 2)});
    top: 0;
  }
  ===
  @use "sass:math"

  .logo
    $width: 800px
    width: $width
    position: absolute
    left: calc(50% - #{math.div($width, 2)})
    top: 0
  ===
  @use "sass:math";

  .logo {
    width: 800px;
    position: absolute;
    left: calc(50% - 400px);
    top: 0;
  }
<% end %>

## `min()` и `max()`

<% impl_status dart: "1.11.0", libsass: false, ruby: false do %>
  LibSass и Ruby Sass в настоящее время *всегда* воспринимает `min()` и `max()` как функции Sass. Чтобы создать простой вызов CSS `min()` или `max()` для этих реализаций, вы можете написать что-то вроде `unquote("min(#{$padding}, env(safe-area-inset-left))")` вместо.
<% end %>

CSS добавил поддержку [функций `min()` и `max()`][`min()` and `max()` functions] в Values и Units Level 4, откуда они были быстро приняты Safari [для поддержки iPhoneX][to support the iPhoneX]. Но Sass поддерживал свои собственные функции [`min()`][] и [`max()`][] задолго до этого, и он должен был быть обратно совместимым со всеми существующими таблицами стилей. Это привело к необходимости особой синтаксической смекалки.

[`min()` and `max()` functions]: https://drafts.csswg.org/css-values-4/#calc-notation
[to support the iPhoneX]: https://webkit.org/blog/7929/designing-websites-for-iphone-x/
[`min()`]: ../modules/math#min
[`max()`]: ../modules/math#max

Если вызов функции `min()` или `max()` является допустимым простым CSS, он будет скомпилирован в вызов CSS `min()` или `max()`. "Обычный CSS" включает вложенные вызовы [`calc()`][], [`env()`][], [`var()`][], `min()` или `max()`, также как и [интерполяция][interpolation]. Однако, как только какая-либо часть вызова содержит функцию SassScript, например [переменные][variables] или [вызовы функций][function calls], вместо этого она анализируется как вызов основной функции Sass `min()` или `max()`.

[`env()`]: https://developer.mozilla.org/en-US/docs/Web/CSS/env
[`var()`]: https://developer.mozilla.org/en-US/docs/Web/CSS/var

<!-- TODO(nweiz): auto-generate this CSS once we're compiling with Dart Sass -->

<% example do %>
  $padding: 12px;

  .post {
    // Поскольку эти вызовы max() не используют никаких функций Sass,
    // кроме интерполяции, они компилируются в вызовы CSS max().
    padding-left: max(#{$padding}, env(safe-area-inset-left));
    padding-right: max(#{$padding}, env(safe-area-inset-right));
  }

  .sidebar {
    // Поскольку они ссылаются на переменную Sass без интерполяции,
    // они вызывают встроенную в Sass функцию max().
    padding-left: max($padding, 20px);
    padding-right: max($padding, 20px);
  }
  ===
  $padding: 12px

  .post
    // Поскольку эти вызовы max() не используют никаких функций Sass,
    // кроме интерполяции, они компилируются в вызовы CSS max().
    padding-left: max(#{$padding}, env(safe-area-inset-left))
    padding-right: max(#{$padding}, env(safe-area-inset-right))


  .sidebar
    // Поскольку они ссылаются на переменную Sass без интерполяции,
    // они вызывают встроенную в Sass функцию max().
    padding-left: max($padding, 20px)
    padding-right: max($padding, 20px)
  ===
  .post {
    padding-left: max(12px, env(safe-area-inset-left));
    padding-right: max(12px, env(safe-area-inset-right));
  }

  .sidebar {
    padding-left: 20px;
    padding-right: 20px;
  }
<% end %>
